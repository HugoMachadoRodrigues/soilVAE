---
title: "soilVAE workflow: PLS vs supervised VAE on real soil spectra"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{soilVAE workflow: PLS vs supervised VAE on real soil spectra}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 4.5,
  warning = FALSE,
  message = FALSE
)

# IMPORTANT (CRAN-safe):
# - The vignette must build without Python/TensorFlow.
# - Python-dependent chunks are guarded by can_run_python() and default to eval = FALSE.

can_run_python <- function() {
  # Opt-in execution locally:
  #   Sys.setenv(SOILVAE_RUN_PY = "1")
  # If that flag is not set, DO NOT try to initialize Python.
  flag <- identical(Sys.getenv("SOILVAE_RUN_PY", unset = "0"), "1")
  if (!flag) return(FALSE)

  if (!requireNamespace("reticulate", quietly = TRUE)) return(FALSE)

  # Avoid initializing Python during checks unless the user explicitly opts-in.
  ok <- FALSE
  try({
    ok <- reticulate::py_available(initialize = FALSE)
  }, silent = TRUE)
  isTRUE(ok)
}
```

## Overview

This vignette reproduces the classic, pedagogical workflow popularized in:

Wadoux, A. M. J.-C., Malone, B., Minasny, B., Fajardo, M., & McBratney, A. B. (2021). *Soil spectral inference with R: Analyzing digital soil spectra using the R programming environment*. Springer. <https://doi.org/10.1007/978-3-030-64896-1>

We use the real dataset `datsoilspc` from the **soilspec** ecosystem and follow the same logic:

1.  Plot reflectance spectra

2.  Convert reflectance to absorbance

3.  Resample wavelengths (5 nm)

4.  Apply SNV + moving average smoothing

5.  Split into calibration/validation

6.  Fit a PLS model and evaluate

7.  Fit a supervised VAE regression model (soilVAE) and evaluate

8.  Compare metrics side-by-side

**CRAN note:** the supervised VAE uses Python TensorFlow/Keras through `reticulate`. If TensorFlow/Keras is not available, the VAE section is skipped automatically (the vignette will still build).

# Packages

```{r}
devtools::load_all()
library(soilVAE)

if (!requireNamespace("prospectr", quietly = TRUE)) {
  stop("Package 'prospectr' is required for this vignette. Please install it.")
}
if (!requireNamespace("pls", quietly = TRUE)) {
  stop("Package 'pls' is required for this vignette. Please install it.")
}

library(prospectr)
library(pls)
```

# Load data

```{r}
# Preferred: dataset stored under data/ as datsoilspc.rda
ok <- FALSE
try({
  data("datsoilspc", package = "soilVAE")
  ok <- TRUE
}, silent = TRUE)

# Fallback: if you store under inst/extdata instead
if (!ok) {
  f <- system.file("extdata", "datsoilspc.rda", package = "soilVAE")
  if (f == "") stop("Could not find datsoilspc in data/ or inst/extdata/.")
  e <- new.env(parent = emptyenv())
  load(f, envir = e)
  if (!exists("datsoilspc", envir = e, inherits = FALSE)) {
    stop("datsoilspc.rda does not contain an object named 'datsoilspc'.")
  }
  datsoilspc <- get("datsoilspc", envir = e)
}

str(datsoilspc)
```

The object contains:

-   `datsoilspc$spc`: spectra in reflectance (rows = samples, columns = wavelengths)

-   soil properties (e.g. `TotalCarbon`)

## Utility: evaluation metrics (base R)

We replicate typical “quantitative” metrics used in soil spectroscopy:\
RMSE, MAE, R², bias (ME), RPIQ, and RPD.

```{r}
eval_quant <- function(y, yhat) {
  y <- as.numeric(y)
  yhat <- as.numeric(yhat)

  ok <- is.finite(y) & is.finite(yhat)
  y <- y[ok]
  yhat <- yhat[ok]

  if (length(y) < 3) {
    return(list(
      n = length(y),
      ME = NA_real_, MAE = NA_real_, RMSE = NA_real_,
      R2 = NA_real_, RPIQ = NA_real_, RPD = NA_real_
    ))
  }

  err <- yhat - y
  me <- mean(err)
  mae <- mean(abs(err))
  rmse <- sqrt(mean(err^2))

  ss_res <- sum((y - yhat)^2)
  ss_tot <- sum((y - mean(y))^2)
  r2 <- if (ss_tot == 0) NA_real_ else 1 - ss_res / ss_tot

  rpiq <- stats::IQR(y) / rmse
  rpd  <- stats::sd(y) / rmse

  list(
    n = length(y),
    ME = me,
    MAE = mae,
    RMSE = rmse,
    R2 = r2,
    RPIQ = rpiq,
    RPD = rpd
  )
}

as_df_metrics <- function(x) {
  data.frame(
    n = x$n,
    ME = x$ME,
    MAE = x$MAE,
    RMSE = x$RMSE,
    R2 = x$R2,
    RPIQ = x$RPIQ,
    RPD = x$RPD,
    stringsAsFactors = FALSE
  )
}
```

# Plot reflectance spectra

```{r}
matplot(
  x = as.numeric(colnames(datsoilspc$spc)),
  y = t(as.matrix(datsoilspc$spc)),
  xlab = "Wavelength / nm",
  ylab = "Reflectance",
  ylim = c(0, 1),
  type = "l",
  lty = 1,
  col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
```

# Convert reflectance to absorbance

```{r}
datsoilspc$spcA <- log(1 / as.matrix(datsoilspc$spc))

matplot(
  x = as.numeric(colnames(datsoilspc$spcA)),
  y = t(datsoilspc$spcA),
  xlab = "Wavelength / nm",
  ylab = "Absorbance",
  ylim = c(0, 4),
  type = "l",
  lty = 1,
  col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
```

# Preprocessing: resample (5 nm) + SNV + moving average

```{r}
oldWavs <- as.numeric(colnames(datsoilspc$spcA))
newWavs <- seq(min(oldWavs), max(oldWavs), by = 5)

datsoilspc$spcARs <- prospectr::resample(
  X = datsoilspc$spcA,
  wav = oldWavs,
  new.wav = newWavs,
  interpol = "linear"
)

datsoilspc$spcASnv <- prospectr::standardNormalVariate(datsoilspc$spcARs)
datsoilspc$spcAMovav <- prospectr::movav(datsoilspc$spcASnv, w = 11)

wavs <- as.numeric(colnames(datsoilspc$spcAMovav))

matplot(
  x = wavs,
  y = t(datsoilspc$spcAMovav),
  xlab = "Wavelength / nm",
  ylab = "Absorbance (SNV + movav)",
  type = "l",
  lty = 1,
  col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
```

# Split calibration vs validation

```{r}
set.seed(19101991)

calId <- sample(seq_len(nrow(datsoilspc)), size = round(0.75 * nrow(datsoilspc)))
datC <- datsoilspc[calId, ]
datV <- datsoilspc[-calId, ]

par(mfrow = c(1, 2))
hist(datC$TotalCarbon, main = "Calibration", xlab = "Total carbon")
hist(datV$TotalCarbon, main = "Validation", xlab = "Total carbon")
par(mfrow = c(1, 1))
```

# Baseline model: PLS

We fit PLS on calibration and evaluate on validation.

```{r}
maxc <- 30

soilCPlsModel <- pls::plsr(
  TotalCarbon ~ spcAMovav,
  data = datC,
  method = "oscorespls",
  ncomp = maxc,
  validation = "CV"
)

plot(soilCPlsModel, "val", main = "PLS CV performance", xlab = "Number of components")
```

# Choose number of components (example uses `nc = 14`).

```{r}
nc <- 14

soilCPlsPred <- predict(soilCPlsModel, ncomp = nc, newdata = datC$spcAMovav)
soilVPlsPred <- predict(soilCPlsModel, ncomp = nc, newdata = datV$spcAMovav)

soilCPlsPred <- as.numeric(soilCPlsPred)
soilVPlsPred <- as.numeric(soilVPlsPred)

par(mfrow = c(1, 2))

plot(datC$TotalCarbon, soilCPlsPred,
     xlab = "Observed", ylab = "Predicted",
     main = "PLS (Calibration)",
     pch = 16)
abline(0, 1)

plot(datV$TotalCarbon, soilVPlsPred,
     xlab = "Observed", ylab = "Predicted",
     main = "PLS (Validation)",
     pch = 16)
abline(0, 1)

par(mfrow = c(1, 1))
```

# Metrics (PLS)

We use the same evaluation function used in many soilspec workflows.

```{r}
pls_cal <- eval_quant(datC$TotalCarbon, soilCPlsPred)
pls_val <- eval_quant(datV$TotalCarbon, soilVPlsPred)

as_df_metrics(pls_cal) |> round(2)
as_df_metrics(pls_val) |> round(2)
```

# Supervised VAE regression: soilVAE

### Availability check (TensorFlow/Keras)

This chunk detects if Python + TensorFlow + Keras can be loaded.\
If not available, the VAE section is skipped (vignette still builds).

```{r}
has_py <- reticulate::py_available(initialize = FALSE)

has_tf <- FALSE
if (has_py) {
  try(reticulate::py_config(), silent = TRUE)

  has_tf <- reticulate::py_module_available("tensorflow") &&
            reticulate::py_module_available("keras")
}

has_py
has_tf
```

### Prepare matrices (same predictors as PLS preprocessing)

We model `TotalCarbon` using the preprocessed spectra matrix `spcAMovav`.

```{r}
X_tr <- as.matrix(datC$spcAMovav)
y_tr <- as.numeric(datC$TotalCarbon)

X_va <- as.matrix(datV$spcAMovav)
y_va <- as.numeric(datV$TotalCarbon)

X_tr <- scale(X_tr)
X_va <- scale(X_va,
              center = attr(X_tr, "scaled:center"),
              scale  = attr(X_tr, "scaled:scale"))

y_tr <- scale(y_tr)
y_va <- scale(y_va,
              center = attr(y_tr, "scaled:center"),
              scale  = attr(y_tr, "scaled:scale"))

dim(X_tr)
length(y_tr)
```

### Fit + evaluate soilVAE (skipped if TF/Keras unavailable)

We keep the tuning small to keep runtime reasonable.

```{r}
# Optional: force a specific python/venv/conda, if needed.
# soilVAE::vae_configure(python = "C:/path/to/python.exe")
# soilVAE::vae_configure(venv = "r-tf311")
# soilVAE::vae_configure(conda = "myenv")

grid_vae <- data.frame(
  latent_dim = c(8L, 16L, 32L, 64L),
  #dropout    = c(0.3, 0.4),
  dropout    = c(0.05),
  #lr         = c(1e-3, 5e-4),
  lr = c(0.0005),
  beta_kl    = c(0.01),
  alpha_y    = c(5),
  epochs     = c(500L),
  batch_size = c(64L),
  patience   = c(50L),
  stringsAsFactors = FALSE
)

grid_vae$hidden_enc <- list(c(512L, 256L, 128L))
grid_vae$hidden_dec <- list(c(128L, 256L, 512L))

tuned <- soilVAE::tune_vae_train_val(
  X_tr = X_tr, y_tr = y_tr,
  X_va = X_va, y_va = y_va,
  seed = 19101991,
  grid_vae = grid_vae
)

best <- soilVAE::select_best_from_grid(tuned$tuning_df, selection_metric = "euclid")
best$best
```

# Refit best configuration and predict.

Now we refit the best configuration once (train on calibration; validate on validation for early stopping) and compute predictions.

```{r}
cfg <- best$best

m_vae <- soilVAE::vae_build(
  input_dim  = ncol(X_tr),
  hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
  hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
  latent_dim = as.integer(cfg$latent_dim),
  dropout    = as.numeric(cfg$dropout),
  lr         = as.numeric(cfg$lr),
  beta_kl    = as.numeric(cfg$beta_kl),
  alpha_y    = as.numeric(cfg$alpha_y)
)

soilVAE::vae_fit(
  model = m_vae,
  X = X_tr, y = y_tr,
  X_val = X_va, y_val = y_va,
  epochs = as.integer(cfg$epochs),
  batch_size = as.integer(cfg$batch_size),
  patience = as.integer(cfg$patience),
  verbose = 0L
)

yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
yhat_va <- soilVAE::vae_predict(m_vae, X_va)
```

Plots: Observed vs Predicted (soilVAE)

```{r}
par(mfrow = c(1, 2))

plot(y_tr, yhat_tr,
     xlab = "Observed", ylab = "Predicted",
     main = "soilVAE (Calibration)",
     pch = 16)
abline(0, 1)

plot(y_va, yhat_va,
     xlab = "Observed", ylab = "Predicted",
     main = "soilVAE (Validation)",
     pch = 16)
abline(0, 1)

par(mfrow = c(1, 1))
```

# Metrics (soilVAE)

```{r}
vae_cal <- eval_quant(y_tr, yhat_tr)
vae_val <- eval_quant(y_va, yhat_va)

as_df_metrics(vae_cal)
as_df_metrics(vae_val)
```

## Compare PLS vs soilVAE

We present a compact comparison table.

```{r}
tab <- rbind(
  cbind(Model = "PLS",    Split = "Calibration", as_df_metrics(pls_cal)),
  cbind(Model = "PLS",    Split = "Validation",  as_df_metrics(pls_val)),
  cbind(Model = "soilVAE",Split = "Calibration", as_df_metrics(vae_cal)),
  cbind(Model = "soilVAE",Split = "Validation",  as_df_metrics(vae_val))
)

row.names(tab) <- NULL
tab
```

If TensorFlow/Keras was not available, you can still use the PLS section and install a compatible Python stack later.

## Notes for reproducibility

-   The PLS workflow depends only on R packages `pls` and `prospectr`.

-   The supervised VAE requires:

```         
-   Python (\>= 3.9)

-   TensorFlow (\>= 2.13)

-   Keras (\>= 3)
```
