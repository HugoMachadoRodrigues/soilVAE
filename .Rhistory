quarto_bin <- Sys.getenv("QUARTO_PATH")
system2(quarto_bin, "-V", stdout = TRUE)
Sys.which("quarto")
system2("quarto", c("TMPDIR=C:/temp", "-V"), stdout = TRUE)
system2("quarto", c("TMPDIR=C:/temp", "-V"), stdout = TRUE)
system2(quarto_bin, "-V", stdout = TRUE)
devtools::document()
devtools::check(args = c("--as-cran"))
# Força o uso do executável (evita cair no .cmd)
Sys.setenv(QUARTO_PATH = Sys.which("quarto"))
# Descobre o caminho do quarto.exe que o R enxerga
Sys.which("quarto")
# Teste (tem que retornar 1.8.25 sem erro)
quarto_bin <- Sys.getenv("QUARTO_PATH")
system2(quarto_bin, "-V", stdout = TRUE)
QUARTO_PATH=C:/Users/rodrigues.h/AppData/Local/Programs/Quarto/bin/quarto.exe
Sys.which("quarto")
system2("quarto", c("TMPDIR=C:/temp", "-V"), stdout = TRUE)
devtools::document()
devtools::check(args = c("--as-cran"))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 7,
fig.height = 4.5,
warning = FALSE,
message = FALSE
)
# IMPORTANT (CRAN-safe):
# - The vignette must build without Python/TensorFlow.
# - Python-dependent chunks are guarded by can_run_python() and default to eval = FALSE.
can_run_python <- function() {
# Opt-in execution locally:
#   Sys.setenv(SOILVAE_RUN_PY = "1")
# If that flag is not set, DO NOT try to initialize Python.
flag <- identical(Sys.getenv("SOILVAE_RUN_PY", unset = "0"), "1")
if (!flag) return(FALSE)
if (!requireNamespace("reticulate", quietly = TRUE)) return(FALSE)
# Avoid initializing Python during checks unless the user explicitly opts-in.
ok <- FALSE
try({
ok <- reticulate::py_available(initialize = FALSE)
}, silent = TRUE)
isTRUE(ok)
}
# Core
library(soilVAE)
# For this vignette (Suggested packages)
if (!requireNamespace("soilspec", quietly = TRUE)) {
stop("Package 'soilspec' is required for this vignette. Please install it.")
}
install.packages("soilspec")
# Core
library(soilVAE)
# For this vignette (Suggested packages)
if (!requireNamespace("soilspec", quietly = TRUE)) {
stop("Package 'soilspec' is required for this vignette. Please install it.")
}
library(soilspec)
install.packages("soilspec")
# For this vignette (Suggested packages)
if (!requireNamespace("soilspec", quietly = TRUE)) {
stop("Package 'soilspec' is required for this vignette. Please install it.")
}
if (!requireNamespace("prospectr", quietly = TRUE)) {
stop("Package 'prospectr' is required for this vignette. Please install it.")
}
if (!requireNamespace("pls", quietly = TRUE)) {
stop("Package 'pls' is required for this vignette. Please install it.")
}
library(soilspec)
library(prospectr)
library(pls)
devtools::document()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 7,
fig.height = 4.5,
warning = FALSE,
message = FALSE
)
# IMPORTANT (CRAN-safe):
# - The vignette must build without Python/TensorFlow.
# - Python-dependent chunks are guarded by can_run_python() and default to eval = FALSE.
can_run_python <- function() {
# Opt-in execution locally:
#   Sys.setenv(SOILVAE_RUN_PY = "1")
# If that flag is not set, DO NOT try to initialize Python.
flag <- identical(Sys.getenv("SOILVAE_RUN_PY", unset = "0"), "1")
if (!flag) return(FALSE)
if (!requireNamespace("reticulate", quietly = TRUE)) return(FALSE)
# Avoid initializing Python during checks unless the user explicitly opts-in.
ok <- FALSE
try({
ok <- reticulate::py_available(initialize = FALSE)
}, silent = TRUE)
isTRUE(ok)
}
library(soilVAE)
if (!requireNamespace("prospectr", quietly = TRUE)) {
stop("Package 'prospectr' is required for this vignette. Please install it.")
}
if (!requireNamespace("pls", quietly = TRUE)) {
stop("Package 'pls' is required for this vignette. Please install it.")
}
library(prospectr)
library(pls)
# Preferred: dataset stored under data/ as datsoilspc.rda
ok <- FALSE
try({
data("datsoilspc", package = "soilVAE")
ok <- TRUE
}, silent = TRUE)
# Fallback: if you store under inst/extdata instead
if (!ok) {
f <- system.file("extdata", "datsoilspc.rda", package = "soilVAE")
if (f == "") stop("Could not find datsoilspc in data/ or inst/extdata/.")
e <- new.env(parent = emptyenv())
load(f, envir = e)
if (!exists("datsoilspc", envir = e, inherits = FALSE)) {
stop("datsoilspc.rda does not contain an object named 'datsoilspc'.")
}
datsoilspc <- get("datsoilspc", envir = e)
}
str(datsoilspc)
eval_quant <- function(y, yhat) {
y <- as.numeric(y)
yhat <- as.numeric(yhat)
ok <- is.finite(y) & is.finite(yhat)
y <- y[ok]
yhat <- yhat[ok]
if (length(y) < 3) {
return(list(
n = length(y),
ME = NA_real_, MAE = NA_real_, RMSE = NA_real_,
R2 = NA_real_, RPIQ = NA_real_, RPD = NA_real_
))
}
err <- yhat - y
me <- mean(err)
mae <- mean(abs(err))
rmse <- sqrt(mean(err^2))
ss_res <- sum((y - yhat)^2)
ss_tot <- sum((y - mean(y))^2)
r2 <- if (ss_tot == 0) NA_real_ else 1 - ss_res / ss_tot
rpiq <- stats::IQR(y) / rmse
rpd  <- stats::sd(y) / rmse
list(
n = length(y),
ME = me,
MAE = mae,
RMSE = rmse,
R2 = r2,
RPIQ = rpiq,
RPD = rpd
)
}
as_df_metrics <- function(x) {
data.frame(
n = x$n,
ME = x$ME,
MAE = x$MAE,
RMSE = x$RMSE,
R2 = x$R2,
RPIQ = x$RPIQ,
RPD = x$RPD,
stringsAsFactors = FALSE
)
}
matplot(
x = as.numeric(colnames(datsoilspc$spc)),
y = t(as.matrix(datsoilspc$spc)),
xlab = "Wavelength / nm",
ylab = "Reflectance",
ylim = c(0, 1),
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
datsoilspc$spcA <- log(1 / as.matrix(datsoilspc$spc))
matplot(
x = as.numeric(colnames(datsoilspc$spcA)),
y = t(datsoilspc$spcA),
xlab = "Wavelength / nm",
ylab = "Absorbance",
ylim = c(0, 4),
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
oldWavs <- as.numeric(colnames(datsoilspc$spcA))
newWavs <- seq(min(oldWavs), max(oldWavs), by = 5)
datsoilspc$spcARs <- prospectr::resample(
X = datsoilspc$spcA,
wav = oldWavs,
new.wav = newWavs,
interpol = "linear"
)
datsoilspc$spcASnv <- prospectr::standardNormalVariate(datsoilspc$spcARs)
datsoilspc$spcAMovav <- prospectr::movav(datsoilspc$spcASnv, w = 11)
wavs <- as.numeric(colnames(datsoilspc$spcAMovav))
matplot(
x = wavs,
y = t(datsoilspc$spcAMovav),
xlab = "Wavelength / nm",
ylab = "Absorbance (SNV + movav)",
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
set.seed(19101991)
calId <- sample(seq_len(nrow(datsoilspc)), size = round(0.75 * nrow(datsoilspc)))
datC <- datsoilspc[calId, ]
datV <- datsoilspc[-calId, ]
par(mfrow = c(1, 2))
hist(datC$TotalCarbon, main = "Calibration", xlab = "Total carbon")
hist(datV$TotalCarbon, main = "Validation", xlab = "Total carbon")
par(mfrow = c(1, 1))
maxc <- 30
soilCPlsModel <- pls::plsr(
TotalCarbon ~ spcAMovav,
data = datC,
method = "oscorespls",
ncomp = maxc,
validation = "CV"
)
plot(soilCPlsModel, "val", main = "PLS CV performance", xlab = "Number of components")
nc <- 14
soilCPlsPred <- predict(soilCPlsModel, ncomp = nc, newdata = datC$spcAMovav)
soilVPlsPred <- predict(soilCPlsModel, ncomp = nc, newdata = datV$spcAMovav)
soilCPlsPred <- as.numeric(soilCPlsPred)
soilVPlsPred <- as.numeric(soilVPlsPred)
par(mfrow = c(1, 2))
plot(datC$TotalCarbon, soilCPlsPred,
xlab = "Observed", ylab = "Predicted",
main = "PLS (Calibration)",
pch = 16)
abline(0, 1)
plot(datV$TotalCarbon, soilVPlsPred,
xlab = "Observed", ylab = "Predicted",
main = "PLS (Validation)",
pch = 16)
abline(0, 1)
par(mfrow = c(1, 1))
pls_cal <- eval_quant(datC$TotalCarbon, soilCPlsPred)
pls_val <- eval_quant(datV$TotalCarbon, soilVPlsPred)
as_df_metrics(pls_cal)
as_df_metrics(pls_val)
as_df_metrics(round(pls_cal, 2))
pls_cal <- eval_quant(datC$TotalCarbon, soilCPlsPred)
pls_val <- eval_quant(datV$TotalCarbon, soilVPlsPred)
as_df_metrics(pls_cal)
as_df_metrics(pls_val)
pls_cal <- eval_quant(datC$TotalCarbon, soilCPlsPred)
pls_val <- eval_quant(datV$TotalCarbon, soilVPlsPred)
as_df_metrics(pls_cal) |> round(2)
as_df_metrics(pls_val) |> round(2)
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
has_py
has_tf
X_tr <- as.matrix(datC$spcAMovav)
y_tr <- as.numeric(datC$TotalCarbon)
X_va <- as.matrix(datV$spcAMovav)
y_va <- as.numeric(datV$TotalCarbon)
dim(X_tr)
length(y_tr)
# Optional: force a specific python/venv/conda, if needed.
# soilVAE::vae_configure(python = "C:/path/to/python.exe")
# soilVAE::vae_configure(venv = "r-tf311")
# soilVAE::vae_configure(conda = "myenv")
grid_vae <- data.frame(
latent_dim = c(16L, 32L),
dropout    = c(0.10, 0.20),
lr         = c(1e-3, 5e-4),
beta_kl    = c(1.0),
alpha_y    = c(1.0),
epochs     = c(40L),
batch_size = c(64L),
patience   = c(8L),
stringsAsFactors = FALSE
)
grid_vae$hidden_enc <- list(c(512L, 256L))
grid_vae$hidden_dec <- list(c(256L, 512L))
tuned <- soilVAE::tune_vae_train_val(
X_tr = X_tr, y_tr = y_tr,
X_va = X_va, y_va = y_va,
seed = 19101991,
grid_vae = grid_vae
)
best <- soilVAE::select_best_from_grid(tuned$tuning_df, selection_metric = "euclid")
best$best
cfg <- best$best
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
yhat_va <- soilVAE::vae_predict(m_vae, X_va)
par(mfrow = c(1, 2))
plot(y_tr, yhat_tr,
xlab = "Observed", ylab = "Predicted",
main = "soilVAE (Calibration)",
pch = 16)
abline(0, 1)
plot(y_va, yhat_va,
xlab = "Observed", ylab = "Predicted",
main = "soilVAE (Validation)",
pch = 16)
abline(0, 1)
par(mfrow = c(1, 1))
vae_cal <- eval_quant(y_tr, yhat_tr)
vae_val <- eval_quant(y_va, yhat_va)
as_df_metrics(vae_cal)
as_df_metrics(vae_val)
# Optional: force a specific python/venv/conda, if needed.
soilVAE::vae_configure(python = "C:/path/to/python.exe")
grid_vae <- data.frame(
latent_dim = c(16L, 32L),
dropout    = c(0.10, 0.20),
lr         = c(1e-3, 5e-4),
beta_kl    = c(1.0),
alpha_y    = c(1.0),
epochs     = c(40L),
batch_size = c(64L),
patience   = c(8L),
stringsAsFactors = FALSE
)
grid_vae$hidden_enc <- list(c(512L, 256L))
tuned <- soilVAE::tune_vae_train_val(
X_tr = X_tr, y_tr = y_tr,
X_va = X_va, y_va = y_va,
seed = 19101991,
grid_vae = grid_vae
)
tuned <- soilVAE::tune_vae_train_val(
X_tr = X_tr, y_tr = y_tr,
X_va = X_va, y_va = y_va,
seed = 19101991,
grid_vae = grid_vae
)
best <- soilVAE::select_best_from_grid(tuned$tuning_df, selection_metric = "euclid")
best$best
```{r}
cfg <- best$best
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 1L
)
yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
yhat_va <- soilVAE::vae_predict(m_vae, X_va)
par(mfrow = c(1, 2))
plot(y_tr, yhat_tr,
xlab = "Observed", ylab = "Predicted",
main = "soilVAE (Calibration)",
pch = 16)
abline(0, 1)
plot(y_va, yhat_va,
xlab = "Observed", ylab = "Predicted",
main = "soilVAE (Validation)",
pch = 16)
abline(0, 1)
par(mfrow = c(1, 1))
vae_cal <- eval_quant(y_tr, yhat_tr)
vae_val <- eval_quant(y_va, yhat_va)
as_df_metrics(vae_cal)
as_df_metrics(vae_val)
cfg <- best$best
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
yhat_va <- soilVAE::vae_predict(m_vae, X_va)
install.packages("reticulate")
reticulate::install_python()
reticulate::virtualenv_create("soilvae-tf")
reticulate::virtualenv_install(
"soilvae-tf",
packages = c("tensorflow>=2.13", "keras>=3"),
ignore_installed = TRUE
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 7,
fig.height = 4.5,
warning = FALSE,
message = FALSE
)
# IMPORTANT (CRAN-safe):
# - The vignette must build without Python/TensorFlow.
# - Python-dependent chunks are guarded by can_run_python() and default to eval = FALSE.
can_run_python <- function() {
# Opt-in execution locally:
#   Sys.setenv(SOILVAE_RUN_PY = "1")
# If that flag is not set, DO NOT try to initialize Python.
flag <- identical(Sys.getenv("SOILVAE_RUN_PY", unset = "0"), "1")
if (!flag) return(FALSE)
if (!requireNamespace("reticulate", quietly = TRUE)) return(FALSE)
# Avoid initializing Python during checks unless the user explicitly opts-in.
ok <- FALSE
try({
ok <- reticulate::py_available(initialize = FALSE)
}, silent = TRUE)
isTRUE(ok)
}
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
if (!has_tf) {
message("Python/TensorFlow/Keras not available. Skipping soilVAE model fit.")
}
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
if (!has_tf) {
message("Python/TensorFlow/Keras not available. Skipping soilVAE model fit.")
}
has_py
has_py <- reticulate::py_available(initialize = FALSE)
has_py
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
has_py
has_tf
soilVAE::vae_configure(venv = "soilvae-tf")
library(soilVAE)
usethis::edit_r_environ()
