cfg <- best$best
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- soilVAE::vae_predict(m_vae, X_tr)
yhat_va <- soilVAE::vae_predict(m_vae, X_va)
install.packages("reticulate")
reticulate::install_python()
reticulate::virtualenv_create("soilvae-tf")
reticulate::virtualenv_install(
"soilvae-tf",
packages = c("tensorflow>=2.13", "keras>=3"),
ignore_installed = TRUE
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.width = 7,
fig.height = 4.5,
warning = FALSE,
message = FALSE
)
# IMPORTANT (CRAN-safe):
# - The vignette must build without Python/TensorFlow.
# - Python-dependent chunks are guarded by can_run_python() and default to eval = FALSE.
can_run_python <- function() {
# Opt-in execution locally:
#   Sys.setenv(SOILVAE_RUN_PY = "1")
# If that flag is not set, DO NOT try to initialize Python.
flag <- identical(Sys.getenv("SOILVAE_RUN_PY", unset = "0"), "1")
if (!flag) return(FALSE)
if (!requireNamespace("reticulate", quietly = TRUE)) return(FALSE)
# Avoid initializing Python during checks unless the user explicitly opts-in.
ok <- FALSE
try({
ok <- reticulate::py_available(initialize = FALSE)
}, silent = TRUE)
isTRUE(ok)
}
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
if (!has_tf) {
message("Python/TensorFlow/Keras not available. Skipping soilVAE model fit.")
}
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
if (!has_tf) {
message("Python/TensorFlow/Keras not available. Skipping soilVAE model fit.")
}
has_py
has_py <- reticulate::py_available(initialize = FALSE)
has_py
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
has_py
has_tf
soilVAE::vae_configure(venv = "soilvae-tf")
library(soilVAE)
usethis::edit_r_environ()
devtools::check_win_release()
devtools::check_win_devel()
install.packages("tinytex")
tinytex::install_tinytex()
tinytex::is_tinytex()
devtools::check(args = "--as-cran")
install.packages("pkgdown")
pkgdown::build_site()
.Last.error
render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
rmarkdown::render("README.Rmd")
set.seed(19101991)
pkgs <- c("prospectr", "pls", "reticulate")
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(prospectr)
library(pls)
library(reticulate)
# soilVAE should already be installed if you're reading this inside the package
library(soilVAE)
set.seed(19101991)
pkgs <- c("prospectr", "pls", "reticulate")
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(prospectr)
library(pls)
library(reticulate)
# soilVAE should already be installed if you're reading this inside the package
library(soilVAE)
data("datsoilspc", package = "soilVAE")
set.seed(19101991)
pkgs <- c("prospectr", "pls", "reticulate")
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(prospectr)
library(pls)
library(reticulate)
if (!requireNamespace("soilVAE", quietly = TRUE)) {
stop("soilVAE is not installed. Install it with remotes::install_github('HugoMachadoRodrigues/soilVAE').")
}
remotes::install_github('HugoMachadoRodrigues/soilVAE')
set.seed(19101991)
pkgs <- c("prospectr", "pls", "reticulate")
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(prospectr)
library(pls)
library(reticulate)
if (!requireNamespace("soilVAE", quietly = TRUE)) {
stop("soilVAE is not installed. Install it with remotes::install_github('HugoMachadoRodrigues/soilVAE').")
}
library(soilVAE)
# Defensive: detect Python + TF/Keras early, so the README can render everywhere.
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
rmarkdown::render("README.Rmd")
data("datsoilspc", package = "soilVAE")
str(datsoilspc)
set.seed(19101991)
pkgs <- c("prospectr", "pls", "reticulate")
for (p in pkgs) if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(prospectr)
library(pls)
library(reticulate)
if (!requireNamespace("soilVAE", quietly = TRUE)) {
stop("soilVAE is not installed. Install it with remotes::install_github('HugoMachadoRodrigues/soilVAE').")
}
library(soilVAE)
# Defensive: detect Python + TF/Keras early, so the README can render everywhere.
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
data("datsoilspc", package = "soilVAE")
str(datsoilspc)
eval_quant <- function(y, yhat) {
y <- as.numeric(y)
yhat <- as.numeric(yhat)
ok <- is.finite(y) & is.finite(yhat)
y <- y[ok]
yhat <- yhat[ok]
if (length(y) < 3) {
return(list(
n = length(y),
ME = NA_real_, MAE = NA_real_, RMSE = NA_real_,
R2 = NA_real_, RPIQ = NA_real_, RPD = NA_real_
))
}
err <- yhat - y
me <- mean(err)
mae <- mean(abs(err))
rmse <- sqrt(mean(err^2))
ss_res <- sum((y - yhat)^2)
ss_tot <- sum((y - mean(y))^2)
r2 <- if (ss_tot == 0) NA_real_ else 1 - ss_res / ss_tot
rpiq <- stats::IQR(y) / rmse
rpd  <- stats::sd(y) / rmse
list(
n = length(y),
ME = me,
MAE = mae,
RMSE = rmse,
R2 = r2,
RPIQ = rpiq,
RPD = rpd
)
}
as_df_metrics <- function(x) {
data.frame(
n = x$n,
ME = round(x$ME, 2),
MAE = round(x$MAE, 2),
RMSE = round(x$RMSE, 2),
R2 = round(x$R2, 2),
RPIQ = round(x$RPIQ, 2),
RPD = round(x$RPD, 2),
stringsAsFactors = FALSE
)
}
matplot(
x = as.numeric(colnames(datsoilspc$spc)),
y = t(as.matrix(datsoilspc$spc)),
xlab = "Wavelength / nm",
ylab = "Reflectance",
ylim = c(0, 1),
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
datsoilspc$spcA <- log(1 / as.matrix(datsoilspc$spc))
matplot(
x = as.numeric(colnames(datsoilspc$spcA)),
y = t(datsoilspc$spcA),
xlab = "Wavelength / nm",
ylab = "Absorbance",
ylim = c(0, 4),
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
oldWavs <- as.numeric(colnames(datsoilspc$spcA))
newWavs <- seq(min(oldWavs), max(oldWavs), by = 5)
datsoilspc$spcARs <- prospectr::resample(
X = datsoilspc$spcA,
wav = oldWavs,
new.wav = newWavs,
interpol = "linear"
)
datsoilspc$spcASnv <- prospectr::standardNormalVariate(datsoilspc$spcARs)
datsoilspc$spcAMovav <- prospectr::movav(datsoilspc$spcASnv, w = 11)
wavs <- as.numeric(colnames(datsoilspc$spcAMovav))
matplot(
x = wavs,
y = t(datsoilspc$spcAMovav),
xlab = "Wavelength / nm",
ylab = "Absorbance (SNV + movav)",
type = "l",
lty = 1,
col = rgb(0.5, 0.5, 0.5, alpha = 0.3)
)
set.seed(19101991)
calId <- sample(seq_len(nrow(datsoilspc)), size = round(0.75 * nrow(datsoilspc)))
datC <- datsoilspc[calId, ]
datV <- datsoilspc[-calId, ]  # <-- TEST
par(mfrow = c(1, 2))
hist(datC$TotalCarbon, main = "Calibration (datC)", xlab = "Total carbon")
hist(datV$TotalCarbon, main = "TEST (datV)", xlab = "Total carbon")
par(mfrow = c(1, 1))
maxc <- 30
soilCPlsModel <- pls::plsr(
TotalCarbon ~ spcAMovav,
data = datC,
method = "oscorespls",
ncomp = maxc,
validation = "CV"
)
plot(soilCPlsModel, "val", main = "PLS CV performance (datC)", xlab = "Number of components")
nc <- 14
# Refit on full datC with chosen nc (PLS itself uses all comps up to maxc; prediction uses nc)
soilCPlsPred_C <- as.numeric(predict(soilCPlsModel, ncomp = nc, newdata = datC$spcAMovav))
soilCPlsPred_T <- as.numeric(predict(soilCPlsModel, ncomp = nc, newdata = datV$spcAMovav))
par(mfrow = c(1, 2))
plot(datC$TotalCarbon, soilCPlsPred_C, xlab="Observed", ylab="Predicted", main="PLS (datC)", pch=16); abline(0,1)
plot(datV$TotalCarbon, soilCPlsPred_T, xlab="Observed", ylab="Predicted", main="PLS (TEST datV)", pch=16); abline(0,1)
par(mfrow = c(1, 1))
pls_cal <- eval_quant(datC$TotalCarbon, soilCPlsPred_C)
pls_tst <- eval_quant(datV$TotalCarbon, soilCPlsPred_T)
as_df_metrics(pls_cal)
as_df_metrics(pls_tst)
has_py <- reticulate::py_available(initialize = FALSE)
has_tf <- FALSE
if (has_py) {
try(reticulate::py_config(), silent = TRUE)
has_tf <- reticulate::py_module_available("tensorflow") &&
reticulate::py_module_available("keras")
}
has_py
has_tf
set.seed(19101991)
nC <- nrow(datC)
id_tr <- sample(seq_len(nC), size = round(0.80 * nC))
datC_tr <- datC[id_tr, ]
datC_va <- datC[-id_tr, ]
# y stays in original units (no transformation)
y_tr <- as.numeric(datC_tr$TotalCarbon)
y_va <- as.numeric(datC_va$TotalCarbon)
# X: scale predictors using TRAIN center/scale only
X_tr_raw <- as.matrix(datC_tr$spcAMovav)
X_va_raw <- as.matrix(datC_va$spcAMovav)
X_te_raw <- as.matrix(datV$spcAMovav)   # TEST
X_tr <- scale(X_tr_raw)
X_center <- attr(X_tr, "scaled:center")
X_scale  <- attr(X_tr, "scaled:scale")
# safe scaling: avoid division by zero
X_scale[X_scale == 0] <- 1
X_va <- scale(X_va_raw, center = X_center, scale = X_scale)
X_te <- scale(X_te_raw, center = X_center, scale = X_scale)
# sanity checks (dims)
dim(X_tr)
length(y_tr)
dim(X_va)
length(y_va)
dim(X_te)
reticulate::py_run_string("
import os
import random
import numpy as np
import tensorflow as tf
os.environ['PYTHONHASHSEED'] = '0'
random.seed(19101991)
np.random.seed(19101991)
tf.random.set_seed(19101991)
")
Sys.setenv(TF_DETERMINISTIC_OPS = "1")
Sys.setenv(TF_CPP_MIN_LOG_LEVEL = "2")         # reduce logs INFO/WARN
Sys.setenv(TF_ENABLE_ONEDNN_OPTS = "0")
if (!has_tf) {
message("TensorFlow/Keras not available; skipping soilVAE section.")
} else {
# Optional: force a specific python/venv/conda, if needed.
# soilVAE::vae_configure(conda = "soilvae-tf")
grid_vae <- data.frame(
latent_dim = c(8L, 16L, 32L, 64L),
dropout    = c(0.20, 0.30),
lr         = c(5e-4),
beta_kl    = c(0.01),
alpha_y    = c(5),
epochs     = c(500L),
batch_size = c(64L, 128L),
patience   = c(50L),
stringsAsFactors = FALSE
)
grid_vae$hidden_enc <- list(c(512L, 256L, 128L))
grid_vae$hidden_dec <- list(c(128L, 256L, 512L))
tuned <- soilVAE::tune_vae_train_val(
X_tr = X_tr, y_tr = y_tr,
X_va = X_va, y_va = y_va,
seed = 19101991,
grid_vae = grid_vae
)
best <- soilVAE::select_best_from_grid(tuned$tuning_df, selection_metric = "euclid")
cfg <- best$best
# Refit on full datC (train+val) using early stopping monitored on the internal val (datC_va)
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- as.numeric(soilVAE::vae_predict(m_vae, X_tr))
yhat_va <- as.numeric(soilVAE::vae_predict(m_vae, X_va))
yhat_te <- as.numeric(soilVAE::vae_predict(m_vae, X_te))
# Metrics: internal train/val + FINAL TEST
vae_trn <- eval_quant(y_tr, yhat_tr)
vae_val <- eval_quant(y_va, yhat_va)
vae_tst <- eval_quant(as.numeric(datV$TotalCarbon), yhat_te)
# Plots
par(mfrow = c(1, 3))
plot(y_tr, yhat_tr, main="soilVAE (Train)", xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
plot(y_va, yhat_va, main="soilVAE (Val)",   xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
plot(as.numeric(datV$TotalCarbon), yhat_te, main="soilVAE (TEST datV)", xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
par(mfrow = c(1, 1))
}
if (!has_tf) {
message("TensorFlow/Keras not available; skipping soilVAE section.")
} else {
Sys.setenv(TF_CPP_MIN_LOG_LEVEL = "2")         # reduce logs INFO/WARN
Sys.setenv(TF_ENABLE_ONEDNN_OPTS = "0")
# Optional: force a specific python/venv/conda, if needed.
# soilVAE::vae_configure(conda = "soilvae-tf")
grid_vae <- data.frame(
latent_dim = c(8L, 16L, 32L, 64L),
dropout    = c(0.20, 0.30),
lr         = c(5e-4),
beta_kl    = c(0.01),
alpha_y    = c(5),
epochs     = c(500L),
batch_size = c(64L, 128L),
patience   = c(50L),
stringsAsFactors = FALSE
)
grid_vae$hidden_enc <- list(c(512L, 256L, 128L))
grid_vae$hidden_dec <- list(c(128L, 256L, 512L))
tuned <- soilVAE::tune_vae_train_val(
X_tr = X_tr, y_tr = y_tr,
X_va = X_va, y_va = y_va,
seed = 19101991,
grid_vae = grid_vae
)
best <- soilVAE::select_best_from_grid(tuned$tuning_df, selection_metric = "euclid")
cfg <- best$best
# Refit on full datC (train+val) using early stopping monitored on the internal val (datC_va)
m_vae <- soilVAE::vae_build(
input_dim  = ncol(X_tr),
hidden_enc = as.integer(strsplit(cfg$hidden_enc_str, "-")[[1]]),
hidden_dec = as.integer(strsplit(cfg$hidden_dec_str, "-")[[1]]),
latent_dim = as.integer(cfg$latent_dim),
dropout    = as.numeric(cfg$dropout),
lr         = as.numeric(cfg$lr),
beta_kl    = as.numeric(cfg$beta_kl),
alpha_y    = as.numeric(cfg$alpha_y)
)
soilVAE::vae_fit(
model = m_vae,
X = X_tr, y = y_tr,
X_val = X_va, y_val = y_va,
epochs = as.integer(cfg$epochs),
batch_size = as.integer(cfg$batch_size),
patience = as.integer(cfg$patience),
verbose = 0L
)
yhat_tr <- as.numeric(soilVAE::vae_predict(m_vae, X_tr))
yhat_va <- as.numeric(soilVAE::vae_predict(m_vae, X_va))
yhat_te <- as.numeric(soilVAE::vae_predict(m_vae, X_te))
# Metrics: internal train/val + FINAL TEST
vae_trn <- eval_quant(y_tr, yhat_tr)
vae_val <- eval_quant(y_va, yhat_va)
vae_tst <- eval_quant(as.numeric(datV$TotalCarbon), yhat_te)
# Plots
par(mfrow = c(1, 3))
plot(y_tr, yhat_tr, main="soilVAE (Train)", xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
plot(y_va, yhat_va, main="soilVAE (Val)",   xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
plot(as.numeric(datV$TotalCarbon), yhat_te, main="soilVAE (TEST datV)", xlab="Observed", ylab="Predicted", pch=16); abline(0,1)
par(mfrow = c(1, 1))
}
if (!has_tf) {
tab <- rbind(
cbind(Model = "PLS", Split = "Calibration (datC)", as_df_metrics(pls_cal)),
cbind(Model = "PLS", Split = "TEST (datV)",        as_df_metrics(pls_tst))
)
} else {
tab <- rbind(
cbind(Model = "PLS",    Split = "Calibration (datC)", as_df_metrics(pls_cal)),
cbind(Model = "PLS",    Split = "TEST (datV)",        as_df_metrics(pls_tst)),
cbind(Model = "soilVAE",Split = "Train (internal)",   as_df_metrics(vae_trn)),
cbind(Model = "soilVAE",Split = "Val (internal)",     as_df_metrics(vae_val)),
cbind(Model = "soilVAE",Split = "TEST (datV)",        as_df_metrics(vae_tst))
)
}
row.names(tab) <- NULL
tab
rmarkdown::render("README.Rmd")
git add .
devtools::check(args = "--as-cran")
pkgdown::build_site()
load_all()
pkgload::load_all()
pkgdown::build_site()
rmarkdown::render("README.Rmd", output_format = "github_document")
pkgdown::build_site()
pkgdown::build_site()
rmarkdown::render("README.Rmd", output_format = "github_document")
pkgdown::build_site()
pkgdown::build_site()
.Last.error
pkgdown::load_all()
pkgload::load_all()
pkgdown::build_site()
pkgload::load_all()
pkgdown::build_site()
pkgload::load_all()
pkgdown::build_site()
devtools::document()
devtools::install(upgrade = "never")
pkgdown::build_site()
?soilVAE::tune_vae_train_val
pkgdown::build_site(new_process = TRUE)
devtools::document()
devtools::install(upgrade = "never")
pkgdown::build_site()
remove.packages("soilVAE")
devtools::document()
devtools::install(upgrade = "never")
pkgdown::build_site()
list.files("man", pattern = "tune_vae_train_val\\.Rd$")
getNamespaceExports("soilVAE")
pkgdown::build_site(new_process = TRUE)
